Character
    name
    Age
    skills (list)
    traits (list)
    associative_memory
    scratch_memory
    focus
    health
    physical condition
    mood
    rest //https://rimworldwiki.com/wiki/Rest#Levels_of_Rest
    food_saturation //https://rimworldwiki.com/wiki/Saturation
    thirsty //https://dwarffortresswiki.org/index.php/Thirst

    Body attributes
        https://dwarffortresswiki.org/index.php/DF2014:Attribute







ch decide if take action based on factors ( skills...) or manually assignment
ch find place for this action (e.x forest:trees)
go to place (time)
execute action (time)
generate or not random event
calculate success percentage of action's result
calculate amount and quality of extracted materials based on factors ( skills, timeframe...)

ch thoughts for this action emotional statement
ch calculate physical condition (tired)
ch calculate needs (hunger, thirst)
ch decide what to do with the materials
ch transfer material to the desired spot


------------------------

ch decide when to eat
ch decide when to drink



Fell trees
Cut down trees
Axe trees
Bring down trees
Timber harvesting
Deforest
Log trees
Harvest timber
Lumber trees
Clear-cut trees
Tree removal
Logging
Tree felling
Timber extraction
Forest clearing
Tree cutting
Tree elimination
Tree destruction
Tree removal
Timber logging

write a list of synonyms for the phrase "fishing"




Angling
Casting a line
Hooking
Trawling
Netting
Fly-fishing
Spearfishing
Seining
Gillnetting
Ice fishing
Freshwater fishing
Saltwater fishing
Sportfishing
Deep-sea fishing
Line fishing
Catching fish
Reeling in
Landing a catch
Noodling fishing
Jug fishing
Rod and reel fishing





Actions (composition)
    move (single -> action)
    talk
    find
    explore
    think
    doTask

Task
    action_pointer = 0
    Actions -> List<action>
        find place/object/person    -> ai or cached
        move to place               -> front
    result

ExecuteActions


"tasks": [
      {
        "id": 1,
        "title": "gather wood from trees",
        "full_descr": "{CHARACTER} want to chop trees.",
        "patterns": [
          "Fell trees",
          "Cut down trees",
          "Axe trees",
          "Bring down trees",
          "Timber harvesting",
          "Log trees",
          "Harvest timber",
          "Lumber trees",
          "Clear-cut trees",
          "Tree removal",
          "Logging",
          "Tree felling",
          "Timber extraction",
          "Forest clearing",
          "Tree cutting",
          "Tree elimination",
          "Tree destruction",
          "Tree removal",
          "Timber logging"
        ],
        "factors": [{"type": "skill", "id" : 1 , "multiplier" : 0.2}
        ],
         "steps": [
            {"action": "find", "params" : 'section/arena/gameObject'}
            {"action": "move", "params" : 'section/arena/gameObject'}
            {"ret": "move", "params" : 'section/arena/gameObject'}
        ],
        "resuts": [{"type": "material", "id" : 1 , "singleU_obtain_time" : 60}
        ]
      },

     class baseAction
        start_time
        end_time
        descr

     class findAction(baseAction)
        find_section      -> ai or existing -> ret string
        find_arena        -> ai or existing -> ret string
        find_game_object  -> ai or existing -> ret string

     class moveAction(baseAction)
        ret section/arena/gameObject -> front will find nearest
        ret {x,y}
        ret null only log to db

     class takeAction(baseAction)
        add_to_inventory
 
    
    GatherWoodTaskExecution
        step 1:
            retFind = decideLocationAction(task.full_descr, character) ret section/arena/gameObject (e.x tree)
            write retFind find at task, not to hit ai all the time
            {task_execution_id :1, id:action_id, action:find, section/arena/gameObject : tree or whatever, callback:onFinish}
        step 2:
            front must send (tree or whatever )
            validate if tree or whatever is valid game object
            interval depends on task results get minimum interval.
            intreval depends on character skill which may increase or decrease the interval
            ret {task_execution_id :1, id:action_id,  action:chop , section/arena/gameObject :tree or whatever, callback:{progress, interval : 60 sec}} 
        step 3:
            interval from previous
                if material update store of materials at front


db TasksExecution
    id
    character_id


onFrontMove
    send api calculate physical condition (tired)
    log player x,y
    log moveAction
 

This is a fictional scenario for a game. 
If the action is not available enclose the action in #.
The probability should always be a number based on reality.

actions available: {find, move, chop tree, mining, collect}

Current activity: Fell trees for wood
1) move to forest
2) find {tree}
3) chop {tree}
probability of find {tree} at forest : 100%

Current activity: collect {gold} 
1) move to mining site
2) mining {gold}
probability of find gold at mining site : 0.2%

Current activity: Gather food from the forest (foraging)
1) move to forest
2) collect {blackberries}
probability of find {blackberries} at forest : 80%

Current activity: Hunt for game in the forest
1) move to forest
2) #hunting# {rabbits}
probability of find {rabbits} at forest : 60%

Current activity: Search for suitable land for farming

--------------------------------------------------------------

It is Medieval Period in a fictional place near a forest where Alex is trying to survive.
What actions should be taken in order to achieve his goals?
List the items in json list.Write one action per row. 
Example output json:[{action:'gather food'}]

[
  { "action": "gather food" },
  { "action": "hunt for game" },
  { "action": "fish in nearby rivers or streams" },
  { "action": "forage for edible plants and mushrooms" },
  { "action": "set up traps for small animals" },
  { "action": "build a shelter using available resources" },
  { "action": "find a water source and ensure it's safe to drink" },
  { "action": "make fire for warmth and cooking" },
  { "action": "craft basic tools for survival" },
  { "action": "be cautious of wild animals and potential threats" }
]

-----------------------------------

available actions: {find, move, chop tree, collect, mining, reeling in}. 
If the available action is not in the available actions set always reply with none.
Be more specific about the result if the statement is too generic.

activity: fell trees for wood to use in building and crafting
real action: fell trees
available action : chop tree
results: [wood logs]

activity: hunt for game in the forest
real action: hunt
available action : none
results: [rabbits, deers]

activity: collect berries, nuts, and edible plants
real action: collect
available action : collect
results: [berries, burdock, dandelion]

activity: trade with other villages




import random

# Initialize a 100x100 grid with all zeros (0 represents ground)
grid_size = 100
grid = [["0"] * grid_size for _ in range(grid_size)]

# Function to add a tree to the grid
def add_tree(grid, x, y):
    if 0 <= x < grid_size and 0 <= y < grid_size:
        grid[y][x] = "ðŸŒ²"

# Function to add a lake to the grid
def add_lake(grid, lake_size):
    # Randomly choose a position for the lake
    lake_x = random.randint(10, grid_size - 20)
    lake_y = random.randint(10, grid_size - 20)

    # Fill the area with "@" to represent the lake
    for i in range(lake_size):
        for j in range(lake_size):
            x = lake_x + i
            y = lake_y + j
            if 0 <= x < grid_size and 0 <= y < grid_size:
                grid[y][x] = "ðŸŒŠ"

# Function to generate a realistic forest
def generate_forest(grid, num_trees):
    for _ in range(num_trees):
        # Randomly choose a position for the tree
        x = random.randint(0, grid_size - 1)
        y = random.randint(0, grid_size - 1)

        # Add the tree to the grid
        add_tree(grid, x, y)

        # Introduce clustering by adding a few more trees around the chosen position
        for _ in range(random.randint(3, 7)):
            add_tree(grid, x + random.randint(-5, 5), y + random.randint(-5, 5))

# Set the number of trees in the forest and lake size
num_trees_in_forest = 500
lake_size = 15

# Generate the lake
add_lake(grid, lake_size)

# Generate the forest
generate_forest(grid, num_trees_in_forest)

# Print the grid
for row in grid:
    print(" ".join(row))




